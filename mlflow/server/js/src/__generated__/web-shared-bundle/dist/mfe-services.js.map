{"version":3,"file":"mfe-services.js","sources":["../src/mfe-services/CommitHash.tsx","../src/mfe-services/comms/rpc-host.ts","../src/mfe-services/comms/rpc-api.ts","../src/mfe-services/MFEStrings.ts","../src/mfe-services/register/isMFE.ts","../src/mfe-services/register/registerMFE.ts","../src/mfe-services/router/HostRouter.ts","../src/mfe-services/session/SessionPolicy.tsx","../src/mfe-services/session/GetSessionConfigRpc.tsx","../src/mfe-services/test-utils/SessionPolicyTestHelper.ts"],"sourcesContent":["declare global {\n  let __GIT_COMMIT_HASH__: string | null | undefined;\n}\n\nexport function commitHash(): string | null | undefined {\n  const buildStr = '<git-sha-to-be-replaced-by-bazel-in-production>';\n  if (buildStr.indexOf('<git-sha') !== 0) {\n    return buildStr;\n  }\n  // eslint-disable-next-line no-undef\n  return __GIT_COMMIT_HASH__;\n}\n","import invariant from 'invariant';\n\nimport type { UnregisterRpcHandler } from './rpc-api';\nimport type { RpcHandlerId, RpcHandlers, RpcRequestParams, RpcResponse } from './rpc-handlers-registry';\nimport type { SafeValue } from './sanitize';\nimport { sanitizeValue } from './sanitize';\n\nconst handlersProp = Symbol('handlers');\n\ntype HandlerFn = (request: any) => Promise<any>;\n\nconst traces = new WeakMap<HandlerFn, string | undefined>();\n\nexport type NoRpcRequestParams = Record<string, never>;\n\n// explicitly marked as Partial<> to indicate a handler might not have been registered\ntype RpcHandlersRegistry = Partial<RpcHandlers>;\n\nfunction getHandlers(): RpcHandlersRegistry {\n  invariant(\n    typeof window.__databricks_mfe_rpc !== 'undefined',\n    `RPC hasn't been initialized or it has been destroyed!`,\n  );\n  // The publicly declared type doesn't have the actual handlers property specified\n  // ideally the handlers will be a private state of this module, but for debugging purposes\n  // it might be beneficial to have an easy access to the list of currently registered handlers\n  return (window.__databricks_mfe_rpc as any)[handlersProp];\n}\n\nfunction registerHandler<Id extends RpcHandlerId>(id: Id, handler: RpcHandlers[Id]): UnregisterRpcHandler {\n  const handlers = getHandlers();\n  const existingHandler = handlers[id];\n  if (existingHandler !== undefined) {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- TODO(FEINF-932)\n      // @ts-ignore ts-migrate(2345) FIXME: Argument of type 'Partial<RpcHandlers>[Id]' is not... Remove this comment to see the full error message\n      `Handler ${id} has already been registered by:\\n ${traces.get(existingHandler) ?? 'missing stack trace'}`,\n    );\n  }\n  const wrappedHandler = wrapHandler(handler);\n\n  handlers[id] = wrappedHandler;\n\n  // capture the current stack trace to be able to report conflicts better\n  traces.set(wrappedHandler, new Error().stack);\n\n  return () => {\n    if (handlers[id] === wrappedHandler) {\n      delete handlers[id];\n    }\n  };\n}\n\nasync function makeCall<Id extends RpcHandlerId>(id: Id, request: RpcRequestParams<Id>): Promise<RpcResponse<Id>> {\n  const handlers = getHandlers();\n  const handler = handlers[id];\n  if (handler === undefined) {\n    throw new Error(`There is no RPC handler for ${id}.`);\n  }\n  // @ts-expect-error For some reason, TypeScript doesn't narrow down the types to the particular types\n  // associated with the given `Id` type (the handler Id) and instead the type of `handler` is the widest\n  // possible type from all handlers, i.e. it represents all handlers at the same time instead of a particular\n  // handler\n  return handler(request);\n}\n\nfunction hasHandlerFor<Id extends RpcHandlerId>(id: Id) {\n  const handlers = getHandlers();\n  return handlers[id] !== undefined;\n}\n\nfunction sanitizeRequest<T extends SafeValue>(request: T): T {\n  return sanitizeValue(request);\n}\n\nfunction sanitizeResponse<T extends SafeValue>(response: T): T {\n  return sanitizeValue(response);\n}\n\nfunction wrapHandler(handler: HandlerFn): HandlerFn {\n  return async (request) => {\n    const safeRequest = sanitizeRequest(request);\n    const response = await handler(safeRequest);\n    return sanitizeResponse(response);\n  };\n}\n\nexport function initRpc() {\n  /**\n   * Allow the handlers structure to be initialized only once upon loading the RPC module.\n   * This aims to minimize the possibility of using a client from one instance and a handler from\n   * another instance.\n   */\n  if (typeof window.__databricks_mfe_rpc !== 'undefined') {\n    // using Reflect.get here to make typescript happy, because the \"official type\" does not have the special symbol\n    // property holding the creation stack\n    throw new Error(\n      `RPC has already been initialized in the current window. To minimize the opportunities for incompatible changes, only one RPC host can be initialized inside a global context`,\n    );\n  }\n\n  const api = Object.freeze({\n    registerHandler,\n    makeCall,\n    hasHandlerFor,\n    [handlersProp]: {},\n  });\n\n  Object.defineProperty(window, '__databricks_mfe_rpc', {\n    configurable: false,\n    writable: false,\n    value: api,\n  });\n}\n","import { useEffect } from 'react';\n\nimport type { RpcHandlerId, RpcRequestParams, RpcResponse, RpcHandlers } from './rpc-handlers-registry';\n\nexport type UnregisterRpcHandler = () => void;\n\n/**\n * Used only internally, do not use directly. Use `defineRpc()` function instead.\n */\nexport interface GlobalRpcApi {\n  makeCall<Id extends RpcHandlerId>(id: Id, request: RpcRequestParams<Id>): Promise<RpcResponse<Id>>;\n  registerHandler<Id extends RpcHandlerId>(id: Id, handler: RpcHandlers[Id]): UnregisterRpcHandler;\n  hasHandlerFor<Id extends RpcHandlerId>(id: Id): boolean;\n}\n\ndeclare global {\n  interface Window {\n    __databricks_mfe_rpc: GlobalRpcApi;\n  }\n}\n\n/*\n * Detects whether RPC library is supported and active.\n */\nexport function isRpcSupported() {\n  return window.__databricks_mfe_rpc !== undefined;\n}\n\nexport function defineRpc<Id extends RpcHandlerId>(id: Id) {\n  function useRegister(handler: RpcHandlers[Id]) {\n    useEffect(() => {\n      const cleanup = register(handler);\n      return cleanup;\n    }, [handler]);\n  }\n\n  function register(handler: RpcHandlers[Id]) {\n    return window.__databricks_mfe_rpc.registerHandler(id, handler);\n  }\n\n  function call(req: RpcRequestParams<Id>): Promise<RpcResponse<Id>> {\n    const result = window.__databricks_mfe_rpc.makeCall(id, req);\n    return result;\n  }\n\n  function isAvailable(): boolean {\n    return isRpcSupported() && window.__databricks_mfe_rpc.hasHandlerFor(id);\n  }\n\n  return {\n    isAvailable,\n    call,\n    register,\n    useRegister,\n  };\n}\n","const MFERootIdSuffix = '-mfe-root';\nconst MFEReactRootIdSuffix = '-mfe-react-root';\n// We currently only support one instance of the portal container.\nexport const MFEReactPortalsContainerId = 'mfe-react-portals';\nconst MFENotificationsPortalIdSuffix = '-mfe-notifications-portal-fallback';\n\ntype MFEHtmlReturn = {\n  mfeRootId: string;\n  mfeReactRootId: string;\n  mfeNotificationsPortalId: string;\n  mfeShadowRootHtml: string;\n};\n\nexport function generateMFEHtml(prefix: string): MFEHtmlReturn {\n  const mfeRootId = prefix + MFERootIdSuffix;\n  const mfeReactRootId = prefix + MFEReactRootIdSuffix;\n  const mfeNotificationsPortalId = prefix + MFENotificationsPortalIdSuffix;\n  const mfeShadowRootHtml = `\n  <div id=\"${mfeRootId}\" class=\"mfe-root\">\n    <div id=\"${MFEReactPortalsContainerId}\"></div>\n    <div id=\"${mfeReactRootId}\"></div>\n    <div id=\"${mfeNotificationsPortalId}\"></div>\n  </div>\n  `.trim();\n  return { mfeRootId, mfeReactRootId, mfeNotificationsPortalId, mfeShadowRootHtml };\n}\n","let mfeId: undefined | string;\n\nexport function setMFE(id: string) {\n  mfeId = id;\n}\n\nexport function isMFE(): boolean {\n  return !!mfeId;\n}\n","import type React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { generateMFEHtml } from '../MFEStrings';\nimport { setMFE } from './isMFE';\n\ntype MFEDeclarationType = {\n  name: string;\n  init: () => void;\n  reactRoot: (shadowRoot: ShadowRoot) => React.FunctionComponentElement<any>;\n  injectStyleURLs?: string[];\n};\n\nfunction createWebComponent(mfe: MFEDeclarationType) {\n  return class MFEWebComponent extends HTMLElement {\n    private static connectedInstances = new Set<MFEWebComponent>();\n    private static previouslyInjectedStyleElements: Array<HTMLStyleElement> = [];\n\n    private reactMountPoint: HTMLElement | null = null;\n    private _shadowRoot: ShadowRoot;\n\n    constructor() {\n      super();\n      this._shadowRoot = this.attachShadow({ mode: 'open' });\n    }\n\n    connectedCallback() {\n      const { mfeShadowRootHtml, mfeReactRootId } = generateMFEHtml(mfe.name);\n      this._shadowRoot.innerHTML = mfeShadowRootHtml.trim();\n      this.reactMountPoint = this._shadowRoot.getElementById(mfeReactRootId);\n\n      MFEWebComponent.connectedInstances.add(this);\n      this.attachStyles();\n\n      const reactRoot = mfe.reactRoot(this._shadowRoot);\n      ReactDOM.render(reactRoot, this.reactMountPoint);\n    }\n\n    disconnectedCallback() {\n      MFEWebComponent.connectedInstances.delete(this);\n      if (this.reactMountPoint) {\n        try {\n          ReactDOM.unmountComponentAtNode(this.reactMountPoint);\n        } catch (ex) {\n          // TODO enable once we have logError in web-shared\n          //logError('An error was thrown while trying to unmount existing React node.', ex as Error);\n        }\n      }\n    }\n\n    /**\n     * Called by Webpack CSS Loader when an MFE module import() css. Applies\n     * CSS to the correct shadow root component.\n     */\n    public static webpackInjectStyle(elem: HTMLStyleElement) {\n      // Notify mounted components.\n      MFEWebComponent.connectedInstances.forEach((wc) => wc.attachStyle(elem));\n      // Import it for future component.\n      if (!MFEWebComponent.previouslyInjectedStyleElements.includes(elem)) {\n        MFEWebComponent.previouslyInjectedStyleElements.push(elem);\n      }\n    }\n\n    private attachStyles() {\n      const stylesFragment = document.createDocumentFragment();\n      stylesFragment.append(\n        ...MFEWebComponent.previouslyInjectedStyleElements,\n        ...(mfe.injectStyleURLs ?? []).map((injectStyleURL) => {\n          const link = document.createElement('link');\n          link.type = 'text/css';\n          link.rel = 'stylesheet';\n          link.href = injectStyleURL;\n          return link;\n        }),\n      );\n      this._shadowRoot.appendChild(stylesFragment);\n    }\n\n    private attachStyle(styleTag: HTMLStyleElement) {\n      this._shadowRoot.appendChild(styleTag);\n    }\n  };\n}\n\nexport function registerMFE(mfe: MFEDeclarationType) {\n  setMFE(mfe.name);\n  mfe.init();\n  customElements.define(`databricks-${mfe.name}`, createWebComponent(mfe));\n}\n","import { defineEvent } from '../comms/events';\nimport { defineRpc } from '../comms/rpc-api';\n\nconst NavigateToRpcHandlerId = 'Router::NavigateTo';\n\nexport type NavigateToOptions = {\n  href: string;\n  replace?: boolean;\n};\n\nexport type NavigateToRpcCallSignature = (req: NavigateToOptions) => Promise<void>;\n\ndeclare module '../comms/rpc-handlers-registry' {\n  interface RpcHandlers {\n    [NavigateToRpcHandlerId]: NavigateToRpcCallSignature;\n  }\n}\n\nexport const navigateToRpc = defineRpc(NavigateToRpcHandlerId);\n\nexport const urlChangedEvent = defineEvent<void>('Router::urlchanged');\n","import invariant from 'invariant';\nimport { useEffect } from 'react';\n\nfunction assertUnreachable(message: string): never {\n  throw new Error(message);\n}\n\nconst SessionPolicyEventType = 'databricks:sessionevent';\n\ninterface CsrfExpiredEventData {\n  type: 'csrfexpired';\n}\n\ninterface SessionExpiredEventData {\n  type: 'sessionexpired';\n}\n\ninterface LoggedInEventData {\n  type: 'loggedin';\n}\n\ninterface LoggedOutEventData {\n  type: 'loggedout';\n  redirectUrl: string;\n}\n\ntype PolicyEventData = CsrfExpiredEventData | SessionExpiredEventData | LoggedInEventData | LoggedOutEventData;\n\n/**\n * Note this function returns `false` if `event.preventDefault()` has been called,\n * `true` otherwise.\n */\nfunction firePolicyEvent(data: PolicyEventData): boolean {\n  const event = new CustomEvent<PolicyEventData>(SessionPolicyEventType, { detail: data, cancelable: true });\n  return window.dispatchEvent(event);\n}\n/**\n * Notify the CSRF token has expired and it has to be refreshed.\n *\n * Returns `false` if the event has been handled, `true` if the\n * fallback logic should be executed.\n */\nexport function notifyCsrfHasExpired() {\n  return firePolicyEvent({ type: 'csrfexpired' });\n}\n\n/**\n * Notify the session has expired and the user will need to login again.\n *\n * Returns `false` if the event has been handled, `true` if the\n * fallback logic should be executed.\n */\nexport function notifySessionHasExpired() {\n  return firePolicyEvent({ type: 'sessionexpired' });\n}\n\n/**\n * Notify the user has logged in.\n *\n * Returns `false` if the event has been handled, `true` if the\n * fallback logic should be executed.\n */\nexport function notifyUserHasLoggedIn() {\n  const runDefaultBehavior = firePolicyEvent({ type: 'loggedin' });\n\n  try {\n    // This signals other tabs that a login has occurred, so they should refresh\n    // If localStorage isn't available this feature does not work.\n    localStorage.setItem('login', new Date().toString());\n  } catch (e) {\n    // ignore errors as this is best effort\n  }\n\n  return runDefaultBehavior;\n}\n\n/**\n * Notify the user has logged out.\n *\n * Returns `false` if the event has been handled, `true` if the\n * fallback logic should be executed.\n */\nexport function notifyUserHasLoggedOut(redirectUrl: string) {\n  const runDefaultBehavior = firePolicyEvent({ type: 'loggedout', redirectUrl });\n\n  try {\n    // This signals other tabs that a logout has occurred, so they should redirect to login screen\n    // If localStorage isn't available this feature does not work.\n    localStorage.setItem('logout', new Date().toString());\n  } catch (e) {\n    // ignore errors as this is best effort\n  }\n\n  return runDefaultBehavior;\n}\n\n/**\n * Defines how to respond to various session-related events like\n * the CSRF or session expiring, the user logging in or out, etc.\n *\n * The policy is free to take the necessary steps in response to any of the\n * events.\n */\nexport interface SessionPolicy {\n  /**\n   * Handles a CSRF expired event, most likely by refreshing the config from the server.\n   */\n  handleCsrfHasExpired(): void;\n\n  /**\n   * Handles a session expired event, most likely by redirecting to the login screen.\n   */\n  handleSessionHasExpired(): void;\n\n  /**\n   * Handles the user has logged in event. The event is triggered when the user has explicitly\n   * logged in one of the tabs.\n   *\n   * @param obj.currentTab Indicates whether the event has occurred in the current tab or not.\n   */\n  handleUserHasLoggedIn(details: { currentTab: boolean }): void;\n\n  /**\n   * Handles the user has logged out event. The event is triggered by an explicit user action\n   * to logout and it can occur in any tab of the application.\n   *\n   * @param obj.currentTab Indicates whether the event has occurred in the current tab or not.\n   */\n  handleUserHasLoggedOut(details: { currentTab: false }): void;\n  handleUserHasLoggedOut(details: { currentTab: true; redirectUrl: string }): void;\n}\n\n/**\n * Sets the session policy, which defines the behavior of the application for various\n * session-related events.\n *\n * Ideally, only a single session policy should be active at a time in order to make sure\n * they don't conflict between each other, but in order to allow for a smooth hand-over,\n * the implementation will allow multiple to co-exist temporary.\n */\nexport function useSessionPolicy(policy: SessionPolicy): void {\n  useEffect(() => setupSessionPolicy(policy), [policy]);\n}\n\nexport function setupSessionPolicy(policy: SessionPolicy) {\n  const customEventListener = policyListener(policy);\n  const storageEventListener = storageListener(policy);\n\n  window.addEventListener(SessionPolicyEventType, customEventListener);\n  window.addEventListener('storage', storageEventListener);\n\n  return () => {\n    window.removeEventListener(SessionPolicyEventType, customEventListener);\n    window.removeEventListener('storage', storageEventListener);\n  };\n}\n\nfunction isPolicyEvent(ev: Event): ev is CustomEvent<PolicyEventData> {\n  return ev.type === SessionPolicyEventType;\n}\n\nfunction policyListener(policy: SessionPolicy) {\n  return (ev: Event) => {\n    invariant(isPolicyEvent(ev), `Expected session policy event to be received, but got ${ev.type}`);\n\n    switch (ev.detail.type) {\n      case 'csrfexpired':\n        ev.preventDefault();\n        policy.handleCsrfHasExpired();\n        return;\n      case 'sessionexpired':\n        ev.preventDefault();\n        policy.handleSessionHasExpired();\n        return;\n      case 'loggedin':\n        ev.preventDefault();\n        policy.handleUserHasLoggedIn({ currentTab: true });\n        return;\n      case 'loggedout':\n        ev.preventDefault();\n        policy.handleUserHasLoggedOut({ currentTab: true, redirectUrl: ev.detail.redirectUrl });\n        return;\n      default:\n        assertUnreachable(`Invalid policy event type: ${ev.detail}`);\n    }\n  };\n}\n\nfunction storageListener(policy: SessionPolicy) {\n  return (ev: StorageEvent) => {\n    switch (ev.key) {\n      case 'login':\n        policy.handleUserHasLoggedIn({ currentTab: false });\n        return;\n      case 'logout':\n        policy.handleUserHasLoggedOut({ currentTab: false });\n        return;\n      default:\n        // ignore\n        return;\n    }\n  };\n}\n","import type { ImmutableType } from '../comms/ImmutableType';\nimport { defineRpc } from '../comms/rpc-api';\n\nconst GetConfigSessionRpcHandlerId = 'Session::GetSessionConfig';\n\n// Defined in UserWorkspacesGetter.scala\nexport interface WorkspaceInfo {\n  name: string;\n  azureLocation: string;\n  orgId: number;\n  needsConfirmation: boolean;\n  deploymentName: string;\n  useRegionalUrl: boolean;\n  owner: string;\n}\n\n/**\n * Defines the minimal set of properties, which should be\n * shared between all MFEs and provides the rest of the properties\n * untyped.\n */\nexport type CoreSessionConfig = {\n  csrfToken: string;\n  availableWorkspaces: WorkspaceInfo[];\n  currentWorkspaceId: string;\n  // this is not in the original API request, but it's added for convenience\n  currentWorkspace?: WorkspaceInfo;\n};\n\nexport type SessionConfig = ImmutableType<CoreSessionConfig> & Record<string, unknown>;\n\nexport type GetSessionConfigRpcCachePolicy = 'cache-only' | 'network-only';\n\nexport type GetSessionConfigRpcRequest = ImmutableType<{ cachePolicy: GetSessionConfigRpcCachePolicy }>;\n\nexport type GetSessionConfigRpcCallSignature = (req: GetSessionConfigRpcRequest) => Promise<SessionConfig>;\n\ndeclare module '../comms/rpc-handlers-registry' {\n  interface RpcHandlers {\n    [GetConfigSessionRpcHandlerId]: GetSessionConfigRpcCallSignature;\n  }\n}\n\nexport const GetSessionConfigRpc = defineRpc(GetConfigSessionRpcHandlerId);\n","/**\n * Simulates a \"user-has-logged-in\" session policy event, which happened in a different tab.\n */\nexport function triggerUserHasLoggedOutInAnotherTab() {\n  window.dispatchEvent(new StorageEvent('storage', { key: 'logout' }));\n}\n\n/**\n * Simulates a \"user-has-logged-in\" session policy event, which happened in a different tab.\n */\nexport function triggerUserHasLoggedInInAnotherTab() {\n  window.dispatchEvent(new StorageEvent('storage', { key: 'login' }));\n}\n"],"names":["commitHash","buildStr","indexOf","__GIT_COMMIT_HASH__","handlersProp","Symbol","traces","WeakMap","getHandlers","invariant","window","__databricks_mfe_rpc","registerHandler","id","handler","handlers","existingHandler","undefined","Error","get","wrappedHandler","wrapHandler","set","stack","makeCall","request","hasHandlerFor","sanitizeRequest","sanitizeValue","sanitizeResponse","response","safeRequest","initRpc","api","Object","freeze","defineProperty","configurable","writable","value","isRpcSupported","defineRpc","useRegister","useEffect","cleanup","register","call","req","result","isAvailable","MFERootIdSuffix","MFEReactRootIdSuffix","MFEReactPortalsContainerId","MFENotificationsPortalIdSuffix","generateMFEHtml","prefix","mfeRootId","mfeReactRootId","mfeNotificationsPortalId","mfeShadowRootHtml","trim","mfeId","setMFE","isMFE","createWebComponent","mfe","MFEWebComponent","HTMLElement","constructor","_shadowRoot","attachShadow","mode","connectedCallback","name","innerHTML","reactMountPoint","getElementById","connectedInstances","add","attachStyles","reactRoot","ReactDOM","render","disconnectedCallback","delete","unmountComponentAtNode","ex","webpackInjectStyle","elem","forEach","wc","attachStyle","previouslyInjectedStyleElements","includes","push","stylesFragment","document","createDocumentFragment","append","injectStyleURLs","map","injectStyleURL","link","createElement","type","rel","href","appendChild","styleTag","Set","registerMFE","init","customElements","define","NavigateToRpcHandlerId","navigateToRpc","urlChangedEvent","defineEvent","assertUnreachable","message","SessionPolicyEventType","firePolicyEvent","data","event","CustomEvent","detail","cancelable","dispatchEvent","notifyCsrfHasExpired","notifySessionHasExpired","notifyUserHasLoggedIn","runDefaultBehavior","localStorage","setItem","Date","toString","e","notifyUserHasLoggedOut","redirectUrl","useSessionPolicy","policy","setupSessionPolicy","customEventListener","policyListener","storageEventListener","storageListener","addEventListener","removeEventListener","isPolicyEvent","ev","preventDefault","handleCsrfHasExpired","handleSessionHasExpired","handleUserHasLoggedIn","currentTab","handleUserHasLoggedOut","key","GetConfigSessionRpcHandlerId","GetSessionConfigRpc","triggerUserHasLoggedOutInAnotherTab","StorageEvent","triggerUserHasLoggedInInAnotherTab"],"mappings":"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"}